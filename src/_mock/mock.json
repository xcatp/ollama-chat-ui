{
  "id": "1-2",
  "cateId": 1,
  "title": "jwt_common",
  "content": "# 概述\r\n\r\n在此文档中，包含可用于JWS签名的标准签名算法及用于JWE加密的认证加密算法与创建CEK的标准密钥管理算法的介绍与使用。\r\n\r\n---\r\n\r\n## 标准签名算法\r\n\r\n标准签名算法用于**JWS**签名与验证，包含**对称密钥算法**和**非对称密钥算法**。\r\n\r\n对称密钥算法指加密与解密使用同一个密钥（代码中表现为`SecretKey`），而非对称密钥算法（代码中表现为`KeyPair`）在加密与解密时使用公钥和私钥。\r\n\r\n标准签名算法在构建JWS时，会利用头部与负载信息与指定的`Key`一起，使用指定的签名算法进行签名；在验证时使用相同的签名算法进行校验。\r\n\r\n\r\n\r\n## 认证加密算法\r\n\r\n认证加密算法用与**JWE**的**加密解密**，所有**6**种认证加密算法都是基于AES的**对称加密算法**。\r\n\r\n## 密钥管理算法\r\n\r\n`JWE`加密解密除了认证加密算法，**还需要**密钥管理算法，用于生成**`CEK`**（内容加密密钥）；密钥管理算法可以是对称或非对称的，取决于需要对称密钥或非对称密钥（如使用`RSA`密钥对，则使用`RSA`密钥管理算法）；\r\n\r\n对于密钥管理算法，JJWT有丰富的选择：可以使用对称密钥、非对称密钥、密码、不使用管理算法。但**推荐**使用的是对称和非对称，取决于使用场景；**不推荐**密码（字节数组）形式。\r\n\r\n使用RSA_OAEP_256密钥管理算法：\r\n\r\n```java\r\nKeyPair pair = Jwts.SIG.RS512.keyPair().build();\r\n// 选择对应的 RSA 密钥管理算法\r\nKeyAlgorithm<PublicKey, PrivateKey> keyAlg = Jwts.KEY.RSA_OAEP_256; // or RSA_OAEP or RSA1_5\r\n// 认证加密算法（6种之一）\r\nAeadAlgorithm enc = Jwts.ENC.A256GCM; // or A192GCM, A128GCM, A256CBC-HS512, etc...\r\n// 使用Alice（接收方）的公钥创建JWE，这样只有使用Alice的私钥才可解密\r\nString jwe = Jwts.builder()\r\n                .audience()\r\n                .add(\"Alice\")\r\n                .and()\r\n                .encryptWith(pair.getPublic(), keyAlg, enc) // <-- Alice's RSA public key\r\n                .compact();\r\n// Alice（接收方）接收并使用私钥解密JWE\r\nSet<String> audience = Jwts.parser()\r\n                .decryptWith(pair.getPrivate()) // <-- Alice's RSA private key\r\n                .build()\r\n                .parseEncryptedClaims(jwe)\r\n                .getPayload()\r\n                .getAudience();\r\n assert audience.contains(\"Alice\");\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n# 标准签名算法(signature algorithm)\r\n\r\nJJWT包括 3 种密钥（secret key）算法和 10 种非对称密钥算法（asymmetric key）。\r\n\r\n下表中，HS系列算法为对称密钥算法；其他为非对称密钥算法。\r\n\r\n## 概要\r\n\r\n| 类型               | 全称 | 系列  | 版本        | 密钥长度(字节) |\r\n| :------------------|---------- | ----- | ----------- | -------------------|\r\n| HMAC |哈希消息验证代码         | SHA   | 256,384,512 | 32/48/64 |\r\n| ECDSA  | 椭圆曲线数字签名算法 | ES    | 256,384,512 | 32/48/65\\|66 |\r\n| RSASSA-PKCS |附加的RSA签名方案-公钥密码学标准 | RS    | 256,384,512 | 2048^ |\r\n| RSASSA-PSS  | 附加的 RSA 签名方案 - 概率签名方案 | PS    | 256,384,512 | 2048^ |\r\n| EdDSA     | 爱德华曲线数字签名算法 | EdDSA | -           | - |\r\n\r\n其中，EdDSA可以使用两条曲线：`Ed25519`, `Ed448`\r\n\r\n| 曲线    | 密钥长度(位) | 产生签名长度（字节） |\r\n| ------- | ------------ | -------------------- |\r\n| Ed25519 | 255          | 64                   |\r\n| Ed448   | 448          | 114                  |\r\n\r\n## 标准签名算法\r\n\r\n| Identifier 标识符 | Signature Algorithm 签名算法                   | 标注   |\r\n| ----------------- | ---------------------------------------------- | ------ |\r\n| `HS256`           | HMAC using SHA-256                             | 对称   |\r\n| `HS384`           | HMAC using SHA-384                             | 对称   |\r\n| `HS512`           | HMAC using SHA-512                             | 对称   |\r\n| `ES256`           | ECDSA using P-256 and SHA-256                  | 非对称 |\r\n| `ES384`           | ECDSA using P-384 and SHA-384                  | 非对称 |\r\n| `ES512`           | ECDSA using P-521 and SHA-512                  | 非对称 |\r\n| `RS256`           | RSASSA-PKCS-v1_5 using SHA-256                 | 非对称 |\r\n| `RS384`           | RSASSA-PKCS-v1_5 using SHA-384                 | 非对称 |\r\n| `RS512`           | RSASSA-PKCS-v1_5 using SHA-512                 | 非对称 |\r\n| `PS256`           | RSASSA-PSS using SHA-256 and MGF1 with SHA-256 | 非对称 |\r\n| `PS384`           | RSASSA-PSS using SHA-384 and MGF1 with SHA-384 | 非对称 |\r\n| `PS512`           | RSASSA-PSS using SHA-512 and MGF1 with SHA-512 | 非对称 |\r\n\r\n## 例子\r\n\r\n### HS 对称密钥算法\r\n\r\n```java\r\nvoid test() {\r\n  SecretKey secretKey = Jwts.SIG.HS512.key().build();\r\n\r\n  String jws = Jwts.builder()\r\n          .signWith(secretKey)\t\t// 签名\r\n          .issuer(\"meow\")\r\n          .compact();\r\n\r\n  Claims payload = Jwts.parser()\r\n          .verifyWith(secretKey)\r\n          .build()\r\n          .parseSignedClaims(jws)  // 验证\r\n          .getPayload();\r\n  assert payload.getIssuer()\r\n          .equals(\"meow\");\r\n}\r\n```\r\n\r\n### RSA 512非对称密钥算法\r\n\r\n```java\r\nvoid test() {\r\n  // KEY， 适合于RSA签名算法\r\n  SignatureAlgorithm alg = Jwts.SIG.RS512.keyPair().build();\r\n\r\n  String jws = Jwts.builder()\r\n    .subject(\"Alice\")\r\n    .signWith(pair.getPrivate())  // 发送方使用RSA私钥创建JWS\r\n    .compact();\r\n\r\n  String subject = Jwts.parser()\r\n    .verifyWith(pair.getPublic())\r\n    .build()\r\n    .parseSignedClaims(jws)     // 接收方使用发送方的公钥来验证签名\r\n    .getPayload()\r\n    .getSubject();\r\n\r\n  assert \"Alice\".equals(subject);\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 认证加密算法\r\n\r\nJWT的任何加密算法都必须是认证加密算法；JWT规范定义了 6 种标准认证加密算法，用于加密JWT负载。\r\n\r\nAead（Authenticated Encryption with Associated Data）是一种加密模式，它提供了对数据进行加密和认证的同时保护关联数据的功能。在使用 AEAD 加密算法时，除了加密的数据外，还可以传递一些额外的关联数据给算法，这些关联数据不会被加密，但会被用于认证。\r\n\r\n下表为6种可用认证加密算法：\r\n\r\n| Identifier 标识符 | Required Key Bit Length 所需的密钥位长度 | Encryption Algorithm 加密算法                                |\r\n| ----------------- | ---------------------------------------- | ------------------------------------------------------------ |\r\n| `A128CBC‑HS256`   | 256                                      | [AES_128_CBC_HMAC_SHA_256](https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.3) |\r\n| `A192CBC-HS384`   | 384                                      | [AES_192_CBC_HMAC_SHA_384](https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.4) |\r\n| `A256CBC-HS512`   | 512                                      | [AES_256_CBC_HMAC_SHA_512](https://www.rfc-editor.org/rfc/rfc7518.html#section-5.2.5) |\r\n| `A128GCM`         | 128                                      | AES GCM using 128-bit key                                    |\r\n| `A192GCM`         | 192                                      | AES GCM using 192-bit key                                    |\r\n| `A256GCM`         | 256                                      | AES GCM using 256-bit key                                    |\r\n\r\n这些都是基于AES的**对称加密**算法，当然非对称加密算法也可以使用，基于密码的密钥推导算法也是，椭圆曲线也是，JWT**间接的**支持它们。\r\n\r\n间接，是因为它们用于**生成用于加密JWT有效负载的实际密钥**。\r\n\r\n## 密钥管理算法\r\n\r\n> 密钥管理算法用来生成内容加密密钥。\r\n\r\nJWT加密可以被认为是一个两步过程：\r\n\r\n1. 生成**内容加密密钥**（Content Encryption Key）\r\n2. 直接将CEK与身份验证加密算法（对称的）一起使用，来实际加密负载\r\n\r\n> 为什么要这么做？\r\n>\r\n> 1. 非对称加密算法往往很慢，相对的，对称加密算法要快的多，这对程序来说很重要。\r\n> 2. 例如，RSA（非对称加密算法的一种）只能加密相对少量的数据。\r\n>\r\n> 为什么不用密码（password）？\r\n>\r\n> - 密码太短，无法保证安全。\r\n\r\n# 标准密钥管理算法（Key Management Algorithm）\r\n\r\nJWT规范定义了 17 种标准密钥管理算法，用于生成内容加密密钥（CEK）。\r\n\r\n| Identifier 标识符    | Key Management Algorithm 密钥管理算法    | 注解                    |\r\n| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\r\n| `RSA1_5`             | RSAES-PKCS1-v1_5                                             ||\r\n| `RSA-OAEP`           | RSAES OAEP using default parameters |使用默认参数的RSAES OAEP|\r\n| `RSA-OAEP-256`       | RSAES OAEP using SHA-256 and MGF1 with SHA-256 |使用SHA-256的RSAES OAEP和使用SHA-256的MGF1|\r\n| `A128KW`             | AES Key Wrap with default initial value using 128-bit key |使用128位密钥的默认初始值的AES密钥包装|\r\n| `A192KW`             | AES Key Wrap with default initial value using 192-bit key |使用192位密钥的默认初始值的AES密钥包装|\r\n| `A256KW`             | AES Key Wrap with default initial value using 256-bit key |使用256位密钥的默认初始值的AES密钥包装|\r\n| `dir`                | Direct use of a shared symmetric key as the Content Encryption Key |直接使用共享对称密钥作为内容加密密钥|\r\n| `ECDH-ES`            | Elliptic Curve Diffie-Hellman Ephemeral Static key agreement using Concat KDF |基于Concat KDF的椭圆曲线Diffie-Hellman短时静态密钥协商|\r\n| `ECDH-ES+A128KW`     | ECDH-ES using Concat KDF and CEK wrapped with \"A128KW\" |ECDH-ES，使用Concat KDF和CEK包装“A128 KW”|\r\n| `ECDH-ES+A192KW`     | ECDH-ES using Concat KDF and CEK wrapped with \"A192KW\" |ECDH-ES，使用Concat KDF和CEK包装“A192 KW”|\r\n| `ECDH-ES+A256KW`     | ECDH-ES using Concat KDF and CEK wrapped with \"A256KW\" |ECDH-ES，使用Concat KDF和CEK包装“A256 KW”|\r\n| `A128GCMKW`          | Key wrapping with AES GCM using 128-bit key |使用128位密钥  使用AES GCM进行密钥包装|\r\n| `A192GCMKW`          | Key wrapping with AES GCM using 192-bit key |使用192位密钥 使用AES GCM进行密钥包装|\r\n| `A256GCMKW`          | Key wrapping with AES GCM using 256-bit key |使用256位密钥 使用AES GCM进行密钥包装|\r\n| `PBES2-HS256+A128KW` | PBES2 with HMAC SHA-256 and \"A128KW\" wrapping |PBES 2，带HMAC SHA-256和“A128 KW”包装|\r\n| `PBES2-HS384+A192KW` | PBES2 with HMAC SHA-384 and \"A192KW\" wrapping |PBES 2，带HMAC SHA-384和“A192 KW”包装|\r\n| `PBES2‑HS512+A256KW` | PBES2 with HMAC SHA-512 and \"A256KW\" wrapping |PBES 2，带HMAC SHA-512和“A256 KW”包装|\r\n\r\n在`io.jsonwebtoken.Jwts.KEY`中注册为常量，作为`io.jsonwebtoken.security.KeyAlgorithm`接口的实现。\r\n\r\n## 如何选择\r\n\r\n---\r\n\r\n### RSA\r\n\r\n> 使用**接收方公钥加密**，**接收方私钥解密**，意味者只有JWE接收方可以解密读取。\r\n\r\n使用算法：`RSA1_5`、`RSA-OAEP`、` RSA-OAEP-256`\r\n\r\n创建时：\r\n\r\n- 生成适合所需加密算法的新的安全随机CEK\r\n\r\n- 使用新的CEK，用所需的加密算法加密JWE有效载荷，产生JWE有效负载密文。\r\n\r\n- 使用指定的RSA密钥包装算法，用JWE接收方的RSA公钥加密CEK本身\r\n\r\n- 将有效负载密文和加密的CEK嵌入到结果JWE中\r\n\r\n解密时：\r\n\r\n- 接收嵌入在JWE内容中的CEK\r\n- 使用RSA私钥，用发现的RSA密钥解包算法解密加密的CEK，产生解密的CEK\r\n- 使用解密的CEK，用JWE识别的加密算法解密JWE密文有效载荷\r\n\r\n---\r\n\r\n### AES\r\n\r\n> 在拥有对称密钥但不想使用该密钥直接加密/解密JWT时使用；\r\n>\r\n> 由于这些特定算法使用对称密钥，因此它们最适合JWE创建者和接收者相同的情况，从而确保密钥不需要与多方共享。\r\n\r\n算法包括：`A128KW` 、 `A192KW` 、 `A256KW` 、 `A128GCMKW` 、 `A192GCMKW` 和 `A256GCMKW`\r\n\r\n每次创建JWE时都会生成一个新的安全随机密钥，被用于直接加密/解密JWT载荷；这个安全随机密钥由`AES Wrap`算法用对称密钥加密，加密的密钥嵌入到生成的JWE中。\r\n\r\n这允许使用随机的短期密钥对JWE进行加密，从而减少潜在的长期对称秘密密钥的材料暴露。\r\n\r\n创建时：\r\n\r\n- 生成适合所需加密算法的新的安全随机CEK\r\n- 使用新的CEK，用所需的加密算法加密JWE有效载荷，产生JWE有效载荷密文。\r\n- 使用指定的AES密钥算法（AES密钥包或AES与GCM加密）加密CEK本身，生成加密的CEK。\r\n- 将有效载荷密文和加密的CEK嵌入结果JWE中。\r\n\r\n解密时：\r\n\r\n- 加密嵌入在JWE中的内容加密密钥（CEK）。\r\n- 使用对称密钥，用发现的AES密钥算法解密加密的CEK。\r\n- 使用解密的CEK，用JWE的识别的加密算法解密JWE密文有效载荷。\r\n\r\n---\r\n\r\n### Dir（直接密钥加密）\r\n\r\n> 用于直接使用对称密钥加密负载\r\n>\r\n> 由于使用对称密钥，所以适合JWE创建和接收者相同的情况。\r\n>\r\n> 这是直接加密最简单的密钥算法，不执行任何密钥加密。本质是no-op密钥算法，允许共享密钥直接加密JWE负责。\r\n\r\n创建时：\r\n\r\n- 使用所需的加密算法直接使用对称密钥对JWE有效载荷进行加密，生成JWE有效载荷密文。\r\n- 将有效载荷密文嵌入结果JWE中。\r\n\r\n**因为该算法不产生加密的密钥值，所以加密的CEK不嵌入到结果JWE中。**\r\n\r\n解密时：\r\n\r\n- 直接使用对称密钥使用的JWE标识的加密算法来解密，不使用加密的CEK。\r\n\r\n---\r\n\r\n\r\n\r\n## PBES（基于密码的密钥加密）\r\n\r\n> 在希望使用密码（字符数组）加解密JWT使用。\r\n>\r\n> 实际上，因为密码通常太弱或有问题不能直接使用，所以这些算法会生成更适合的密码密钥。\r\n>\r\n> 这允许使用随机的短期密码学上更强的密钥对有效载荷进行加密，从而减少了暴露长期（并且可能更弱）密码的需要。\r\n>\r\n> 这些算法使用秘密密码，所以它们最适合JWE创建者和接收者相同的情况，确保秘密密码不需要与多方共享。\r\n\r\n算法包括： `PBES2-HS256+A128KW` 、 `PBES2-HS384+A192KW` 和 `PBES2-HS512+A256KW` \r\n\r\n创建时：\r\n\r\n- 生成适合所需加密算法的新的安全随机内容加密密钥（CEK）。\r\n- 使用新的CEK，用所需的加密算法加密JWE有效载荷，产生JWE有效载荷密文。\r\n- 使用密码、适当的计算迭代次数和安全随机盐值，通过所需的“PBES2 with HMAC SHA”算法导出“密钥加密密钥”（KEK）。\r\n- 使用密码派生的KEK，使用相应的AES密钥包装算法加密生成的CEK。\r\n- 将有效载荷密文和加密的CEK嵌入结果JWE中。\r\n\r\n> 在使用这些算法时，如果没有指定工作因子（即计算迭代次数），JJWT将自动使用OWASP PBKDF 2推荐的适用于指定 `PBES2` 算法的默认值\r\n\r\n解密时：\r\n\r\n- 加密嵌入在JWE中的内容加密密钥（CEK）。\r\n- 使用JWE报头中发现的密码和计算迭代次数以及安全随机盐值，使用发现的“PBES2 with HMAC SHA”算法导出“密钥加密密钥”（KEK）。\r\n- 使用密码导出的KEK，使用相应的AES密钥展开算法解密加密的CEK。\r\n- 使用解密的CEK，用JWE的识别的加密算法解密JWE密文有效载荷。\r\n\r\n---\r\n\r\n## ECDH-ES\r\n\r\n使用与RSA一致，同样使用接收方公钥加密，私钥解密。但原理过程不一样。\r\n\r\n创建时：\r\n\r\n- 获取用于加密JWE有效载荷的内容加密密钥（CEK），如下所示：\r\n  - 检查JWE接收方的椭圆曲线公钥并确定其曲线。\r\n  - 在同一曲线上生成新的安全随机临时椭圆曲线公钥/私钥对。\r\n  - 将临时EC公钥添加到JWE epk头中，以包含在最终JWE中。\r\n  - 使用JWE接收方的EC公钥和临时EC私钥，通过ECDH密钥协商算法生成ECDH共享密钥。\r\n  - 使用此ECDH共享密钥和任何提供的PartyUInfo和/或PartyVInfo，通过Concat密钥推导函数（NIST.800- 56 A，第5.8.1节）推导对称密钥。\r\n  - 如果密钥算法为 `ECDH-ES` ：\r\n    - 直接使用Concat KDF派生的对称密钥作为内容加密密钥（CEK）。没有加密的密钥被创建，也没有嵌入到结果JWE中。\r\n  - 否则，如果密钥算法为 `ECDH-ES+A128KW` 、 `ECDH-ES+A192KW` 或 `ECDH-ES+A256KW` ：\r\n    - 生成适合所需加密算法的新的安全随机内容加密密钥（CEK）。\r\n    - 使用Concat KDF派生的秘密密钥，使用相应的AES密钥包装算法加密这个新的CEK，产生加密的CEK。\r\n    - 将加密的CEK嵌入到结果JWE中。\r\n- 使用所获得的CEK，用所需的加密算法加密JWE有效载荷，产生JWE有效载荷密文。\r\n- 将有效载荷密文嵌入结果JWE中。\r\n\r\n解密时：\r\n\r\n- 获取用于解密JWE有效载荷的内容加密密钥（CEK），如下所示：\r\n  - 从JWE的epk头中删除所需的临时椭圆曲线公钥。\r\n  - 确保临时EC公钥与JWE接收者的EC私钥存在于同一曲线上。\r\n  - 使用JWE接收方的EC私钥和临时EC公钥，通过ECDH密钥协商算法生成ECDH共享密钥。\r\n  - 使用此ECDH共享密钥和在JWE报头中找到的任何PartyUInfo和/或PartyVInfo，通过Concat密钥推导函数（NIST.800- 56 A，第5.8.1节）推导对称密钥。\r\n  - 如果密钥算法为 `ECDH-ES` ：\r\n    - 直接使用Concat KDF派生的秘密密钥作为内容加密密钥（CEK）。不使用加密密钥。\r\n  - 否则，如果密钥算法为 `ECDH-ES+A128KW` 、 `ECDH-ES+A192KW` 或 `ECDH-ES+A256KW` ：\r\n    - 获取JWE中嵌入的加密密钥密文。\r\n    - 使用Concat KDF派生的秘密密钥，使用关联的AES密钥解包算法解密加密的密钥密文，产生未加密的内容加密密钥（CEK）。\r\n- 使用所获得的CEK，用JWE的发现的加密算法解密JWE有效载荷密文。\r\n\r\n---\r\n\r\n至此，适用于JWE密钥管理算法介绍完成。\r\n\r\n",
  "createTime": "2024-08-21 00:07:05",
  "updateTime": "2024-03-29 21:31:17"
}